Here is my workaround (and it is a workaround; I am dealing with a in-place DB which was designed poorly IMO).

Originally sourced from: https://forum.hibernate.org/viewtopic.php?f=25&amp;t=979685&amp;view=previous

Here is my custom string class (in VB):

	Imports NHibernate.UserTypes
	Imports NHibernate.Type
	Imports NHibernate.SqlTypes

	Public Class CaseInsensitiveStringType
		Inherits AbstractStringType

		&#39; Methods
		Public Sub New()
			MyBase.New(New StringSqlType)
		End Sub

		Public Sub New(ByVal sqlType As StringSqlType)
			MyBase.New(sqlType)
		End Sub


		&#39; Properties
		Public Overrides ReadOnly Property Name As String
			Get
				Return &quot;InsensitiveString&quot;
			End Get
		End Property

		Public Overrides Function IsEqual(ByVal x As Object, ByVal y As Object) As Boolean
			Return MyBase.IsEqual(x, y) OrElse (x IsNot Nothing AndAlso y IsNot Nothing AndAlso String.Equals(x, y, StringComparison.InvariantCultureIgnoreCase))
		End Function

		Public Overrides Function GetHashCode(ByVal x As Object, ByVal entityMode As NHibernate.EntityMode, ByVal factory As NHibernate.Engine.ISessionFactoryImplementor) As Integer
			Return MyBase.GetHashCode(x.ToString().Trim().ToUpperInvariant(), entityMode, factory)
		End Function
	End Class

And I use FluentNhibernate, so here is what the mapping looks like (only apply to Id fields):

    Id(Function(x) x.Id).GeneratedBy.Assigned().CustomType(Of CaseInsensitiveStringType)()

And that was that; my associations started to be populated properly again.

Again, it is MUCH better to design your DB correctly using int/GUID PKs rather than strings, but if you have to, this is a decent way of &quot;fixing&quot; NHibernate.
I don&#39;t understand your problem :

- when you query by the PK with Get method, the object returned has no value for the relationships
- when you query by another kind of query (an example will be useful), the relationships are not empty ?



For consistency sake, please revise this:

    &lt;joined-subclass name=&quot;JohnHarmanLtd.Web.FineArtCompany.Models.Book, App_Code.tqeub3fb, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null&quot;&gt;

More specifically &quot;**App_Code.tqeub3fb**&quot;. It looks like you&#39;re using temporary assemblies from an ASP.NET Website as part of the mapping for NHibernate? 

Move your Business Entities out into their own library so the assembly name is always the same.


There is no option for this but you can achieve the same using QBE


    Example.create(parent).ignoreCase() 
I have the exact same situation on a ref table in my DB. I mapped the schema file the same way you did. In code, when I query for the record by Primary Key, I do the following using an instance of the NHibernate ISession:

    return session.Get&lt;T&gt;(id);

In this statement, T is the type you are querying for, and id is the string id you are looking for (the Primary Key)

Here is an example of my mapping file:

        &lt;class name=&quot;Merchant&quot; table=&quot;T__MERCHANT&quot;&gt;
            &lt;id name=&quot;MerchantId&quot; column=&quot;MERCHANT_ID&quot; type=&quot;string&quot;&gt;
                &lt;generator class=&quot;assigned&quot; /&gt;
            &lt;/id&gt;
    
            &lt;property name=&quot;MerchantStatusId&quot; column=&quot;MERCHANT_STATUS_ID&quot; type=&quot;Char&quot; not-null=&quot;true&quot; length=&quot;1&quot; /&gt;
            &lt;property name=&quot;MerchantStatusName&quot; column=&quot;MERCHANT_STATUS_NAME&quot; type=&quot;string&quot; length=&quot;50&quot; /&gt;
            &lt;property name=&quot;MerchantName&quot; column=&quot;NAME&quot; type=&quot;string&quot; not-null=&quot;true&quot; length=&quot;50&quot; /&gt;
     &lt;/class&gt;
    &lt;/hibernate-mapping&gt;

And my C# code looks like this:

    public Merchant GetMerchantById(string id)
    {
         return session.Get&lt;Merchant&gt;(id);
    }