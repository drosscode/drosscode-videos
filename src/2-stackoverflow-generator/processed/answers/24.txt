Unfortunately, using  NSString -stringWithFont:forWidth:lineBreakMode: doesn&#39;t work - which ever wrap mode you choose, the text wraps with a width that is less than the current width, and the height becomes 0 on any overflow lines. To get a real figure, fit the string into a frame that is taller than the one you need - then you&#39;ll get a height that is greater than your actual height.

Note my fudge in this (subtracting 15 from the width). This might be something to do with my views (I have one within another), so you might not need it.

    - (BOOL)textView:(UITextView *)aTextView shouldChangeTextInRange:(NSRange)aRange replacementText:(NSString*)aText
    {
            NSString* newText = [aTextView.text stringByReplacingCharactersInRange:aRange withString:aText];
        	
            // TODO - find out why the size of the string is smaller than the actual width, so that you get extra, wrapped characters unless you take something off
            CGSize tallerSize = CGSizeMake(aTextView.frame.size.width-15,aTextView.frame.size.height*2); // pretend there&#39;s more vertical space to get that extra line to check on
            CGSize newSize = [newText sizeWithFont:aTextView.font constrainedToSize:tallerSize lineBreakMode:UILineBreakModeWordWrap];
        
            if (newSize.height &gt; aTextView.frame.size.height)
                {
                [myAppDelegate beep];
                return NO;
                }
            else
                return YES;
    }