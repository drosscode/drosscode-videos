Type inference.  After being incredibly frustrated by Java&#39;s cumbersome, bureaucratic type-specification contraption, discovering SML and seeing that static typing *can* be almost effortless was a real eye-opener (and made me even *more* frustrated with Java...).  Mind you, I haven&#39;t *used* a type-inferring language since (generally, either I don&#39;t get to choose language or I choose Python), but seeing what can be done has greatly affected my attitude about what *is* done...

[***Map*** and ***Reduce***][1]


  [1]: http://en.wikipedia.org/wiki/MapReduce
Not the most recent, but I started out programming as a hobbyist. I became a whiz at it, learned everything I needed to know by self-study. I went to college to earn my 2-year degree in computer science, sailed through my classes, and learned precisely no new information. It was too easy, and having contributed to messageboards and seeing others struggle, I self-evaluated myself to be at least as a good a programmer as any 10-year veteran.

So then I got my first programming job. When I go to hammer out my first lines of code, the kind that would actually be used by other people, it hit me really hard: &lt;b&gt;I suck at writing code&lt;/b&gt;.

Just having a chance to look at other people&#39;s code, listen to them talk about DLLs, version control, putting assemblies the GAC, design patterns, test-driven development, all of these other foreign concepts that no one ever bothered to mention in college made me realize that I barely knew anything about programming whatsoever. College and self-study did nothing to prepare me for the real deal. It turns out I could hammer out code to do whatever I wanted, but I was not a high-level thinker at all, and whatever code I churned out was positively awful.

Well, a good 6 months of real-world experience fixed that up, helped to condition away some bad habits, and gave me a good feel for what code should actually look like. So, here I am, feeling good about myself, but I run into a problem I can&#39;t solve: I have an object nested 5 levels deep inside another object, and I want it to notify the outermost object that its state had changed. I couldn&#39;t figure out an obvious way to do it, so I consult a coworker who loans me a book on Java design patterns. I read the book and it opened my eyes about how much I was missing: there was a whole world of design patterns that I&#39;d never seen before, proposing elegant solutions to problems that I would have never thought of.

And then it hit me again, all this time I&#39;d been missing out on so much, I&#39;m not a high-level thinker at all, and the hacks I wrote to solve the same problems described in the GoF book made it even obvious: &lt;b&gt;I suck at writing code&lt;/b&gt;.

Another 6 more months and I was a master of design patterns. I lived and breathed abstract factories, ranted at length on why MVC is vastly superior to MVP, prayed to a golden idol of Martin Fowler next to my bedside. So, in any case, I wanted to boost my resume by learning a few additional languages. I added Python, C#, Perl to the list, but I got really bored learning the same things over and over with just a subtle change in syntax. I decided I&#39;d look at a weird language, and I came across a few a few snippets of Haskell. Not knowing what the language was, I read about and discovered an entire programming paradigm called functional programming. Just for funsies, I learned a functional programming language (I chose OCaml over Haskell and Lisp), and it completely changed how I thought about programming.

After running that little experiment, it hit me again: &lt;b&gt;I suck at writing code&lt;/b&gt;

How has this universe of functional programming existed without me ever knowing about it? Why didn&#39;t anyone tell me about it sooner? To think, I used to take pride in my capacity to pump out dozens and dozens of Java classes, literally 1000s of lines of code creating hierarchies of abstract factories, concrete factories, visitors, etc etc etc. When I became proficient with OCaml, the line count in my applications dropped by a factor of 20:1. Dozens of would-be Java hierarchies collapsed down into a few OCaml unions, all of which fit on a single screen. I&#39;ve been riding the functional programming train ever since.

The lesson here is simple: if you think you&#39;re the best programmer, you suck. The &quot;I know everything there is to know&quot; mindset is naive and will limit your capacity to become a truly excellent programmer.
We can learn that a lot of fancy names are just names given over to old fashioned ideas that have been spruced up a bit and formalised.
closures, [lambda functions][1] ...


  [1]: http://www.secnetix.de/olli/Python/lambda_functions.hawk
Don&#39;t know if these would count as paradigm shift but...

* [Lambda calculus][4]
* [Bayes&#39; Theorem][5]

Is a few eye-opener last year when I was still in college.


  [1]: http://en.wikipedia.org/wiki/Object-oriented_programming
  [2]: http://www.google.co.th/search?rlz=1C1GGLS_enTH291TH304&amp;sourceid=chrome&amp;ie=UTF-8&amp;q=operating+system
  [3]: http://en.wikipedia.org/wiki/Theory_of_computation
  [4]: http://en.wikipedia.org/wiki/Lambda_calculus
  [5]: http://yudkowsky.net/rational/bayes
[Test-Driven Development][1]?


  [1]: http://www.agiledata.org/essays/tdd.html
3GL to 4GL ;)
Dependency injection and inversion of control for me.
