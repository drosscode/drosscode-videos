According to the document link you give you&#39;re only going to get this QHoverEvent if your widget has the `Qt::WA_Hover` flag.

After constructing the widget call:

    widget-&gt;setAttribute(Qt::WA_Hover);

and see if it works.

Another way of achieving the same result is to override `mouseMoveEvent()` in your widget  
notice that this function too will not be normally called unless you call:

    widget-&gt;setMouseTracking(true);

This is basically how QT implements the hover event internally.
Using signals and slots for this purpose isn&#39;t going to work.

`mouseMoveEvent()` is not a signal or meta-method and cannot be connected to a slot.

Subclassing the widget class and overriding `mouseMoveEvent()` will allow you to get mouse-move-events, but that is a very heavyweight way to accomplish this (and adds one more class to your source base).

Instead, consider implementing an `eventFilter()` method on your `MyDialog` class and installing it on the `QLabel`. With this event filter method, you can intercept all the events for a given `QObject` instance.

Here is the documentation on Event Filters.

  [http://doc.qt.io/qt-4.8/eventsandfilters.html#event-filters][1]

Additionally, through looking at the code sample, I&#39;d recommend you take a moment to investigate what the `SIGNAL()` and `SLOT()` macros do. You can see how they are defined in `$QTDIR/src/corelib/kernel/qobjectdefs.h`


  [1]: http://doc.qt.io/qt-4.8/eventsandfilters.html#event-filters
You need to subclass or filter [focusInEvent][1] and [focusOutEvent][2] of that particular widget. 


  [1]: http://doc.trolltech.com/4.5/qwidget.html#focusInEvent
  [2]: http://doc.trolltech.com/4.5/qwidget.html#focusOutEvent
http://qt-project.org/doc/qt-5/qwidget.html#enterEvent

http://qt-project.org/doc/qt-5/qwidget.html#leaveEvent

http://qt-project.org/doc/qt-5/qt.html#widget-attributes

Qt::WA_Hover
-------

&gt; Forces Qt to generate paint events when the mouse enters or leaves the
&gt; widget. This feature is typically used when implementing custom
&gt; styles; see the Styles example for details.

http://qt-project.org/doc/qt-5/qtwidgets-widgets-styles-example.html#norwegianwoodstyle-class-implementation

&gt; This `QStyle::polish()` overload is called once on every widget drawn
&gt; using the style. We reimplement it to set the `Qt::WA_Hover` attribute
&gt; on `QPushButtons` and `QComboBoxes`. When this attribute is set, Qt
&gt; generates paint events when the mouse pointer enters or leaves the
&gt; widget. This makes it possible to render push buttons and comboboxes
&gt; differently when the mouse pointer is over them.



How to receive Enter and Leave Events on a `QWidget`
-------------

1. Set the Widget Attribute for WA_Hover

        // in your widget&#39;s constructor (probably)
        this-&gt;setAttribute(Qt::WA_HOVER, true);

2. Implement `QWidget::enterEvent()` and `QWidget::leaveEvent()`.

		void Widget::enterEvent(QEvent * event)
		{
			qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; this-&gt;objectName();
			QWidget::enterEvent(event);
		}

		void Widget::leaveEvent(QEvent * event)
		{
			qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; this-&gt;objectName();
			QWidget::leaveEvent(event);
		}

3. Done

QHoverEvent in QWidget
-------------
http://qt-project.org/doc/qt-5/qhoverevent.html#details

http://qt-project.org/doc/qt-5/qobject.html#event

http://qt-project.org/doc/qt-5/qwidget.html#event

    // in your widget&#39;s constructor (probably)
    this-&gt;setAttribute(Qt::WA_HOVER, true);
    // ...

	void Widget::hoverEnter(QHoverEvent * event) {qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; this-&gt;objectName();}
	void Widget::hoverLeave(QHoverEvent * event) {qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; this-&gt;objectName();}
	void Widget::hoverMove(QHoverEvent * event) {qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; this-&gt;objectName();}

	bool Widget::event(QEvent * e)
	{
		switch(e-&gt;type())
		{
		case QEvent::HoverEnter:
			hoverEnter(static_cast&lt;QHoverEvent*&gt;(e));
			return true;
			break;
		case QEvent::HoverLeave:
			hoverLeave(static_cast&lt;QHoverEvent*&gt;(e));
			return true;
			break;
		case QEvent::HoverMove:
			hoverMove(static_cast&lt;QHoverEvent*&gt;(e));
			return true;
			break;
		default:
			break;
		}
		return QWidget::event(e);
	}

**UPDATE:**

Simple Example
--------------
Hover the button and see the count change.  Look at the application output for more information.

https://gist.github.com/peteristhegreat/d6564cd0992351f98aa94f869be36f77

Hope that helps.
`QHoverEvent` is only for hover widgets, you want to implement the `enterEvent` and `leaveEvent` handlers by subclassing the widget instead.
If you want to use an event filter instead, the corresponding event types are `QEvent::Enter` and `QEvent::Leave`.

If you simply need to change the appearance of the widget, you might want to look into Qt stylesheets, as they provide a `:hover` selector.
I was having the same issue, I came to the following solution design:

In my main widget, I&#39;d like to process hover events of some selected objects. For this reason, I created 2 slots on my `MainWindow`:

    public slots:
        void onHoverIn(QObject* object);
        void onHoverOut(QObject* object);

Then I created an Event Filter class like this:

hovereventfilter.h

    #ifndef HOVEREVENTFILTER_H
    #define HOVEREVENTFILTER_H
    
    #include &lt;QObject&gt;
    #include &lt;QEvent&gt;
    
    class HoverEventFilter : public QObject
    {
        Q_OBJECT
    public:
        explicit HoverEventFilter(QObject *parent = 0);
    
    signals:
        void HoverIn(QObject *);
        void HoverOut(QObject *);
    
    public slots:
    
    protected:
        bool eventFilter(QObject *watched, QEvent *event);
    };
    
    #endif // HOVEREVENTFILTER_H

hovereventfilter.cpp

    #include &quot;hovereventfilter.h&quot;
    
    HoverEventFilter::HoverEventFilter(QObject *parent) : QObject(parent)
    {
    
    }
    
    bool HoverEventFilter::eventFilter(QObject *watched, QEvent *event)
    {
    
        QEvent::Type t = event-&gt;type();
    
        switch(t){
        case QEvent::Enter:
            emit HoverIn(watched);
            break;
    
        case QEvent::Leave:
            emit HoverOut(watched);
            break;
        default:
            return false;
        }
    
        return true;
    }


You can see this class will fire either HoverIn or HoverOut depending on what happened. **This approach does not need settings of `Qt::WA_Hover`**

Now as last step, we need to instruct which elements are to be filtered and connect signals and slots. I will create a private pointer to event filter in mainwindow.h

    class MainWindow : public QWidget
    {
        Q_OBJECT
    
    ...
    
    public slots:
        void onHoverIn(QObject* object);
        void onHoverOut(QObject* object);
    
    private:
    
        HoverEventFilter* hoverEventFilter;
    
    ...
    
    };

And in constructor, I add this:

    this-&gt;hoverEventFilter = new HoverEventFilter(this);
    
    connect(this-&gt;hoverEventFilter, SIGNAL(HoverIn(QObject*)), this, SLOT(onHoverIn(QObject*)));
    connect(this-&gt;hoverEventFilter, SIGNAL(HoverOut(QObject*)), this, SLOT(onHoverOut(QObject*)));



Now whenever I wish to receive hover events on some object, I just set event filter on it, like this:
   

    this-&gt;ui-&gt;someLabelOrWhatever-&gt;installEventFilter(this-&gt;hoverEventFilter);

What is left is implementation of `onHoverIn` and `onHoverOut` in `MainWindow`. They both share the same idea so I will show just `onHoverIn`


    void MainWindow::onHoverIn(QObject *object)
    {
        QString objectName = object-&gt;objectName();
    
        switch(objectName){
            // do something depending on name of the widget
        }
    }


You can extend this so easily, to process hover events on new item, you just set an event listener on it and take care of what you wish to do in the `onHoverIn` and `onHoverOut` methods. No need to subclass any widgets.