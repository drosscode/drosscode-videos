A lambda expression can either be converted to a delegate type or an expression tree - but it has to know *which* delegate type. Just knowing the signature isn&#39;t enough. For instance, suppose I have:

    public delegate void Action1();
    public delegate void Action2();

    ...

    Delegate x = () =&gt; Console.WriteLine(&quot;hi&quot;);

What would you expect the concrete type of the object referred to by `x` to be? Yes, the compiler *could* generate a new delegate type with an appropriate signature, but that&#39;s rarely useful and you end up with less opportunity for error checking.

If you want to make it easy to call `Control.Invoke` with an `Action` the easiest thing to do is add an extension method to Control:

    public static void Invoke(this Control control, Action action)
    {
        control.Invoke((Delegate) action);
    }
Tired of casting lambdas over and over?

    public sealed class Lambda&lt;T&gt;
    {
        public static Func&lt;T, T&gt; Cast = x =&gt; x;
    }
    
    public class Example
    {
        public void Run()
        {
            // Declare
            var c = Lambda&lt;Func&lt;int, string&gt;&gt;.Cast;
            // Use
            var f1 = c(x =&gt; x.ToString());
            var f2 = c(x =&gt; &quot;Hello!&quot;);
            var f3 = c(x =&gt; (x + x).ToString());
        }
    }


Nine tenths of the time people get this because they are trying to marshal onto the UI thread. Here&#39;s the lazy way:

    static void UI(Action action) 
    { 
      System.Windows.Threading.Dispatcher.CurrentDispatcher.BeginInvoke(action); 
    }

Now that it&#39;s typed, the problem goes away (qv Skeet&#39;s anwer) and we have this very succinct syntax:

    int foo = 5;
    public void SomeMethod()
    {
      var bar = &quot;a string&quot;;
      UI(() =&gt;
      {
        //lifting is marvellous, anything in scope where the lambda
        //expression is defined is available to the asynch code
        someTextBlock.Text = string.Format(&quot;{0} = {1}&quot;, foo, bar);        
      });
    }

For bonus points here&#39;s another tip. You wouldn&#39;t do this for UI stuff but in cases where you need SomeMethod to block till it completes (eg request/response I/O, waiting for the response) use a [WaitHandle][1] (qv msdn WaitAll, WaitAny, WaitOne). 

Note that AutoResetEvent is a WaitHandle derivative.

    public void BlockingMethod()
    {
      AutoResetEvent are = new AutoResetEvent(false);
      ThreadPool.QueueUserWorkItem ((state) =&gt;
      {
        //do asynch stuff        
        are.Set();
      });      
      are.WaitOne(); //don&#39;t exit till asynch stuff finishes
    }

And a final tip because things can get tangled: WaitHandles stall the thread. This is what they&#39;re supposed to do. If you try to marshal onto the UI thread *while you have it stalled*, your app will hang. In this case (a) some serious refactoring is in order, and (b) as a temporary hack you can wait like this:

      bool wait = true;
      ThreadPool.QueueUserWorkItem ((state) =&gt;
      {
        //do asynch stuff        
        wait = false;
      });
      while (wait) Thread.Sleep(100);

  [1]: http://msdn.microsoft.com/en-us/library/9f7e54k1.aspx
Peter Wone. you are da man.
Taking your concept a bit further, I came up with these two functions.

    private void UIA(Action action) {this.Invoke(action);}
    private T UIF&lt;T&gt;(Func&lt;T&gt; func) {return (T)this.Invoke(func);}

I place these two functions into my Form app, and I can make calls from background workers like this

    int row = 5;
    string ip = UIF&lt;string&gt;(() =&gt; this.GetIp(row));
    bool r = GoPingIt(ip);
    UIA(() =&gt; this.SetPing(i, r));

Maybe a bit lazy, but i don&#39;t have to setup worker done functions, 
which comes in super handy in cases such as this

    private void Ping_DoWork(object sender, System.ComponentModel.DoWorkEventArgs e)
    {
      int count = this.dg.Rows.Count;
      System.Threading.Tasks.Parallel.For(0, count, i =&gt; 
      {
        string ip = UIF&lt;string&gt;(() =&gt; this.GetIp(i));
        bool r = GoPingIt(ip);
        UIA(() =&gt; this.SetPing(i, r));
      });
      UIA(() =&gt; SetAllControlsEnabled(true));
    }

Essentially, get some ip addresses from a gui DataGridView, ping them, set the resulting icons to green or red, and reenable buttons on the form. Yes, it is a &quot;parallel.for&quot; in a backgroundworker. Yes it is a LOT of invoking overhead, but its negligible for short lists, and much more compact code. 

I tried to build this upon [@Andrey Naumov][1]&#39;s answer. May be this is a slight improvement.

    public sealed class Lambda&lt;S&gt;
    {
        public static Func&lt;S, T&gt; CreateFunc&lt;T&gt;(Func&lt;S, T&gt; func)
        {
            return func;
        }

        public static Expression&lt;Func&lt;S, T&gt;&gt; CreateExpression&lt;T&gt;(Expression&lt;Func&lt;S, T&gt;&gt; expression)
        {
            return expression;
        }

        public Func&lt;S, T&gt; Func&lt;T&gt;(Func&lt;S, T&gt; func)
        {
            return func;
        }

        public Expression&lt;Func&lt;S, T&gt;&gt; Expression&lt;T&gt;(Expression&lt;Func&lt;S, T&gt;&gt; expression)
        {
            return expression;
        }
    }

Where type parameter `S` is the formal parameter (the input parameter, which is minimum required to infer rest of the types). Now you can call it like:

    var l = new Lambda&lt;int&gt;();
    var d1 = l.Func(x =&gt; x.ToString());
    var e1 = l.Expression(x =&gt; &quot;Hello!&quot;);
    var d2 = l.Func(x =&gt; x + x);

    //or if you have only one lambda, consider a static overload
    var e2 = Lambda&lt;int&gt;.CreateExpression(x =&gt; &quot;Hello!&quot;);

You can have additional overloads for `Action&lt;S&gt;` and `Expression&lt;Action&lt;S&gt;&gt;` similarly in the same class. For *other* built in delegate and expression types, you will have to write separate classes like `Lambda`, `Lambda&lt;S, T&gt;`, `Lambda&lt;S, T, U&gt;` etc.

Advantage of this I see over the original approach:

1. One less type specification (only the formal parameter needs to be specified). 

2. Which gives you the freedom to use it against any `Func&lt;int, T&gt;`, not just when `T` is say, `string`, as shown in examples.

3. Supports expressions straight away. In the earlier approach you will have to specify types again, like:

        var e = Lambda&lt;Expression&lt;Func&lt;int, string&gt;&gt;&gt;.Cast(x =&gt; &quot;Hello!&quot;);

        //or in case &#39;Cast&#39; is an instance member on non-generic &#39;Lambda&#39; class:
        var e = lambda.Cast&lt;Expression&lt;Func&lt;int, string&gt;&gt;&gt;(x =&gt; &quot;Hello!&quot;);

 for expressions.

4. Extending the class for other delegate (and expression) types is similarly cumbersome like above.

        var e = Lambda&lt;Action&lt;int&gt;&gt;.Cast(x =&gt; x.ToString());

        //or for Expression&lt;Action&lt;T&gt;&gt; if &#39;Cast&#39; is an instance member on non-generic &#39;Lambda&#39; class:
        var e = lambda.Cast&lt;Expression&lt;Action&lt;int&gt;&gt;&gt;(x =&gt; x.ToString());

In my approach you have to declare types only once (that too one less for `Func`s).


  [1]: https://stackoverflow.com/a/714044/661933

---
One another way to implement Andrey&#39;s answer is like not going fully generic

    public sealed class Lambda&lt;T&gt;
    {
        public static Func&lt;Func&lt;T, object&gt;, Func&lt;T, object&gt;&gt; Func = x =&gt; x;
        public static Func&lt;Expression&lt;Func&lt;T, object&gt;&gt;, Expression&lt;Func&lt;T, object&gt;&gt;&gt; Expression = x =&gt; x;
    }

So things reduce to: 

    var l = Lambda&lt;int&gt;.Expression;
    var e1 = l(x =&gt; x.ToString());
    var e2 = l(x =&gt; &quot;Hello!&quot;);
    var e3 = l(x =&gt; x + x);

That&#39;s even less typing, but you lose certain type safety, and **imo, this is not worth it.**
     this.Dispatcher.Invoke((Action)(() =&gt; { textBox1.Text = &quot;Test 123&quot;; }));
Bit late to the party but you can also cast like this

    this.BeginInvoke((Action)delegate {
        // do awesome stuff
    });
Playing with XUnit and [Fluent Assertions](https://fluentassertions.com/introduction) it was possible to use this inline capability in a way I find really cool.

**Before**
```
[Fact]
public void Pass_Open_Connection_Without_Provider()
{
    Action action = () =&gt; {
        using (var c = DbProviderFactories.GetFactory(&quot;MySql.Data.MySqlClient&quot;).CreateConnection())
        {
            c.ConnectionString = &quot;&lt;xxx&gt;&quot;;
            c.Open();
        }
    };
            
    action.Should().Throw&lt;Exception&gt;().WithMessage(&quot;xxx&quot;);
}
```

**After**
```
[Fact]
public void Pass_Open_Connection_Without_Provider()
{
    ((Action)(() =&gt; {
        using (var c = DbProviderFactories.GetFactory(&quot;&lt;provider&gt;&quot;).CreateConnection())
        {
            c.ConnectionString = &quot;&lt;connection&gt;&quot;;
            c.Open();
        }
    })).Should().Throw&lt;Exception&gt;().WithMessage(&quot;Unable to find the requested .Net Framework Data Provider.  It may not be installed.&quot;);
}
```
Other answers were correct at the time they were written, but starting from C# 10.0 (from 2021), the compiler _can_ infer a suitable delegate type (like some `Func&lt;...&gt;`, `Action&lt;...&gt;` or generated delegate type) in such cases.

See [C# 10 Features - Lambda improvements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/lambda-improvements).

```
string str = &quot;woop&quot;;
Invoke(() =&gt; this.Text = str);   // OK in C# 10.0, in this case &#39;Func&lt;string&gt;&#39; is picked
```
```
string str = &quot;woop&quot;;
Invoke(() =&gt; { this.Text = str; });   // OK in C# 10.0, in this case &#39;Action&#39; is picked
```
Comments assume the signature `Invoke(Delegate method)` as in your question. Of course if the method wants a particular (not abstract) delegate type, C# will attempt to convert the lambda into that one, as was also the case before C# 10.0.