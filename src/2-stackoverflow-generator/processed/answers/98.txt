It is not possible to do this directly. `build` is explicitly designed only to deal with
source code in the same or parent directory of the `sources` file. It cannot use source files from arbitrary locations. In particular, its dependency-tracking system seems unable to parse and track remote files, and therefore it explicitly checks and enforces that all files be local.

There are two common solutions:

1. Build remote code as a separate lib (either via another subproject/directory in the same `build` project, or using an independent build step).

2. Place a local stub for each remote source file which does `#include &quot;../../remote_source.cpp`, and add this local stub to the `SOURCES=` list, instead. This will work, but `build`/`nmake` will *not* track dependencies in the `remote_source.cpp`. If `remote_source.cpp` changes, you will have to either `touch` the local proxy source, or otherwise force a rebuild (delete the local proxy obj, run `build` with `-cZ`, or otherwise).
An alternate way is to use source.inc to include these files.
Hate to resurrect a super old topic, but I just ran into this as well.

An alternate alternate way is to create another sources file inside that solely builds object files of the remote source, so basically a file named **somewhere_else\sources**, and give it the same intermediate directory. 

Then add a &#39;dirs&#39; file to your original directory and specify that remote folder inside. Then link directly to the object file by adding something like this to the original sources file:

    $(TARGETLIBS) = $(PROJECT_OBJ_ROOT)\$(O)\source.obj

This way, you don&#39;t have to compile as a lib, but build treats it like one and links without any dependency checking or care of location.

***Naturally you might run into some problems if you give them the same intermediate directory and the same original source file name (source.cpp)***