Spring has one feature that it can inject parameters to constructor or property based on the parameter name or position. This is very useful if the parameter or property is a simple type (e.g. an integer, a boolean). See [the example here][1]. I don&#39;t think that this really makes up for Spring&#39;s inability to do config in code. 

Windsor can also do this, and can do it in code not config. (correct me if I&#39;m wrong, I&#39;m just going via what I&#39;ve heard here).

I would like to know if Unity can do this.

  [1]: http://therning.org/niklas/2006/09/spring-and-named-constructor-arguments/
One thing to note: Ninject is the only IoC container that supports contextual dependency injections (as per their Web site). However, because I don&#39;t have experience with other IoC containers, I can&#39;t tell if that holds.
Just to add my 2 cents, I&#39;ve tried both StructureMap and Unity. I found StructureMap to be poorly/misguidingly documented, a pain in the butt to configure, and clunky to use. Likewise, it doesn&#39;t seem to support scenarios like constructor argument overrides at resolution time, which was a key usage point for me. So I dropped it and went with Unity, and had it doing what I wanted in about 20 minutes.
I personally use Unity, but only because it is from Microsoft.  I regret the decision for one reason: the biggest thing it has against it has one big &quot;bug&quot; that causes it to constantly throws exceptions.  You can ignore the exceptions while debugging. However it slows down your application **tremendously** if you run across it, since throwing an exception is an expensive operation.  For example, I&#39;m currently &quot;fixing&quot; this exception in one spot in my code where Unity&#39;s exceptions adds an extra **4 seconds** to a page&#39;s render time.  For more details and a workaround, see:

[https://stackoverflow.com/questions/2873767/can-unity-be-made-to-not-throw-synchronizationlockexception-all-the-time][1]


  [1]: https://stackoverflow.com/questions/2873767/can-unity-be-made-to-not-throw-synchronizationlockexception-all-the-time
Old thread but since this is the first thing that Google showed me when I typed in unity vs spring.net...

Spring does do CodeConfig now if you don&#39;t like XML config

http://www.springframework.net/codeconfig/doc-latest/reference/html/

Also, Spring is much more than just an DI container, if you look at the &#39;Modules&#39; section in the docs, the DI container is the foundation of the huge stack of things it does. 
As far as I&#39;ve seen they are pretty much the same, except for a few implementation details here and there. The biggest advantage that Unity has over the competition is that it is provided by Microsoft, there are lots of companies out there that are afraid of OSS.

One disadvantage is that it&#39;s rather new so it might have bugs that the older players have already sorted out.

Having said that, you might want to [check this out][1].


  [1]: http://weblogs.asp.net/podwysocki/archive/2008/02/22/ioc-and-the-unity-application-block-going-deeper.aspx
Correct me if I&#39;m mistaken but I think Autofac itself supports XML Configuration as listed in this link: [Autofac XML Configuration][1]


  [1]: http://code.google.com/p/autofac/wiki/XmlConfiguration
I am preparing a presentation for a usergroup. As such I just went through a bunch of them.  Namely: AutoFac, MEF, Ninject, Spring.Net, StructureMap, Unity, and Windsor.

I wanted to show off the 90% case (constructor injection, which is mainly what people use an IOC for anyway).
[You can check out the solution here (VS2008)][1]


As such, there are a few key differences:

* Initialization
* Object retrieval

Each of them have other features as well (some have AOP, and better gizmos, but generally all I want an IOC to do is create and retrieve objects for me)

Note: the differences between the different libraries object retrieval can be negated by using the CommonServiceLocator: http://www.codeplex.com/CommonServiceLocator

That leaves us with initialization, which is done in two ways: via code or via XML configuration (app.config/web.config/custom.config).  Some support both, some support only one.  I should note: some use attributes to help the IoC along.

So here is my assessment of the differences:

### [Ninject][2]

Code initialization only (with attributes).  I hope you like lambdas.  Initialization code looks like this:

     IKernel kernel = new StandardKernel(
                    new InlineModule(
                        x =&gt; x.Bind&lt;ICustomerRepository&gt;().To&lt;CustomerRepository&gt;(),
                        x =&gt; x.Bind&lt;ICustomerService&gt;().To&lt;CustomerService&gt;(),
                        x =&gt; x.Bind&lt;Form1&gt;().ToSelf()
                        ));

### [StructureMap][3]

Initialization code or XML or Attributes.  v2.5 is also very lambda&#39;y.  All in all, this is one of my favorites.  Some very interesting ideas around how StructureMap uses Attributes.

    ObjectFactory.Initialize(x =&gt;
    {
        x.UseDefaultStructureMapConfigFile = false;
        x.ForRequestedType&lt;ICustomerRepository&gt;()
            .TheDefaultIsConcreteType&lt;CustomerRepository&gt;()
            .CacheBy(InstanceScope.Singleton);
    
        x.ForRequestedType&lt;ICustomerService&gt;()
            .TheDefaultIsConcreteType&lt;CustomerService&gt;()
            .CacheBy(InstanceScope.Singleton);
    
        x.ForConcreteType&lt;Form1&gt;();
     });

### [Unity][4]

Initialization code and XML.  Nice library, but XML configuration is a pain in the butt.  Great library for Microsoft or the highway shops.
Code initialization is easy:

     container.RegisterType&lt;ICustomerRepository, CustomerRepository&gt;()
              .RegisterType&lt;ICustomerService, CustomerService&gt;();

### [Spring.NET][5]

XML only as near as I can tell. But for functionality Spring.Net does everything under the sun that an IoC can do.  But because the only way to unitize is through XML it is generally avoided by .net shops.  Although, many .net/Java shop use Spring.Net because of the similarity between the .net version of Spring.Net and the Java Spring project. 

**Note**: Configuration in the code is now possible with the introduction of [Spring.NET CodeConfig](http://www.springframework.net/codeconfig/).

### [Windsor][6]

XML and code. Like Spring.Net, Windsor will do anything you could want it to do.  Windsor is probably one of the most popular IoC containers around.

    IWindsorContainer container = new WindsorContainer();
    container.AddComponentWithLifestyle&lt;ICustomerRepository, CustomerRepository&gt;(&quot;CustomerRepository&quot;, LifestyleType.Singleton);
    container.AddComponentWithLifestyle&lt;ICustomerService, CustomerService&gt;(&quot;CustomerService&quot;,LifestyleType.Singleton);
    container.AddComponent&lt;Form1&gt;(&quot;Form1&quot;);


### [Autofac][7]

Can mix both XML and code (with v1.2).  Nice simple IoC library.  Seems to do the basics with not much fuss. Supports nested containers with local scoping of components and a well-defined life-time management.

Here is how you initialize it:

    var builder = new ContainerBuilder();
    builder.Register&lt;CustomerRepository&gt;()
            .As&lt;ICustomerRepository&gt;()
            .ContainerScoped();
    builder.Register&lt;CustomerService&gt;()
            .As&lt;ICustomerService&gt;()
            .ContainerScoped();
    builder.Register&lt;Form1&gt;();

----

If I had to choose today: I would probably go with StructureMap.  It has the best support for C# 3.0 language features, and the most flexibility in initialization.

**Note**: Chris Brandsma turned his original answer into a [blog post][8].


  [1]: https://cid-b0ed6c076f2f2bfe.skydrive.live.com/self.aspx/Public/IocDemo.zip
  [2]: http://ninject.org/
  [3]: http://structuremap.sourceforge.net/
  [4]: http://codeplex.com/unity
  [5]: http://www.springframework.net/
  [6]: http://www.castleproject.org/container/index.html
  [7]: http://code.google.com/p/autofac/
  [8]: http://elegantcode.com/2009/01/07/ioc-libraries-compared/
