We actually have some notification code in our product that uses TLS to send mail if it is available.

You will need to set the Java Mail properties. You only need the TLS one but you might need SSL if your SMTP server uses SSL.

    Properties props = new Properties();
    props.put(&quot;mail.smtp.starttls.enable&quot;,&quot;true&quot;);
    props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);  // If you need to authenticate
    // Use the following if you need SSL
    props.put(&quot;mail.smtp.socketFactory.port&quot;, d_port);
    props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);
    props.put(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;);


You can then either pass this to a JavaMail Session or any other session instantiator like `Session.getDefaultInstance(props)`.
The settings from the example above didn&#39;t work for the server I was using ([authsmtp.com][1]).  I kept on getting this error:

    javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection?

I removed the mail.smtp.socketFactory settings and everything worked.  The final settings were this (SMTP auth was not used and I set the port elsewhere):

    java.util.Properties props = new java.util.Properties();
    props.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);

  [1]: http://www.authsmtp.com/
Good post, the line 

    props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);

is mandatory if the SMTP server uses **SSL Authentication**, like the GMail SMTP server does. However if the server uses **Plaintext Authentication over TLS**, it should not be present, because Java Mail will complain about the initial connection being plaintext.

Also make sure you are using the latest version of Java Mail. Recently I used some old Java Mail jars from a previous project and could not make the code work, because the login process was failing. After I have upgraded to the latest version of Java Mail, the reason of the error became clear: it was a javax.net.ssl.SSLHandshakeException, which was not thrown up in the old version of the lib.
Just use the following code.  It is really useful to send email via Java, and it works: 
    
    import java.util.*;
    import javax.activation.CommandMap;
    import javax.activation.MailcapCommandMap;
    import javax.mail.*;
    import javax.mail.Provider;
    import javax.mail.internet.*;
    
    public class Main {
    
    	public static void main(String[] args) {
                final String username=&quot;your@gmail.com&quot;;
                final String password=&quot;password&quot;;
                Properties prop=new Properties();
                prop.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);
                prop.put(&quot;mail.smtp.host&quot;, &quot;smtp.gmail.com&quot;);
                prop.put(&quot;mail.smtp.port&quot;, &quot;587&quot;);
                prop.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);
    
                Session session = Session.getDefaultInstance(prop,
    		  new javax.mail.Authenticator() {
    			protected PasswordAuthentication getPasswordAuthentication() {
    				return new PasswordAuthentication(username, password);
    		  }
    	    });
              try {
                     String body=&quot;Dear Renish Khunt Welcome&quot;;
                     String htmlBody = &quot;&lt;strong&gt;This is an HTML Message&lt;/strong&gt;&quot;;
                     String textBody = &quot;This is a Text Message.&quot;;
    		 Message message = new MimeMessage(session);
    		 message.setFrom(new InternetAddress(&quot;your@gmail.com&quot;));
    		         message.setRecipients(Message.RecipientType.TO,InternetAddress.parse(&quot;receiver@gmail.com&quot;));
    		message.setSubject(&quot;Testing Subject&quot;);
            MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap();
            mc.addMailcap(&quot;text/html;; x-java-content-handler=com.sun.mail.handlers.text_html&quot;);
            mc.addMailcap(&quot;text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml&quot;);
            mc.addMailcap(&quot;text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain&quot;);
            mc.addMailcap(&quot;multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed&quot;);
            mc.addMailcap(&quot;message/rfc822;; x-java-content-handler=com.sun.mail.handlers.message_rfc822&quot;);
            CommandMap.setDefaultCommandMap(mc);
    			message.setText(htmlBody);
                            message.setContent(textBody, &quot;text/html&quot;);
    			Transport.send(message);
    
    			System.out.println(&quot;Done&quot;);
    
    		} catch (MessagingException e) {
    			e.printStackTrace();
    		}
    
        }
    
    }
With [Simple Java Mail 5.0.0](http://simplejavamail.org) (simplejavamail.org) it is very straightforward and the library will take care of all the Session properties for you.

Here&#39;s an example using Google&#39;s SMTP servers:

    Email email = EmailBuilder.startingBlank()
            .from(&quot;lollypop&quot;, &quot;lol.pop@somemail.com&quot;)
            .to(&quot;C.Cane&quot;, &quot;candycane@candyshop.org&quot;)
            .withSubject(&quot;hey&quot;)
            .withPlainText(&quot;We should meet up!&quot;)
            .withHTMLText(&quot;&lt;b&gt;We should meet up!&lt;/b&gt;&quot;)
            .buildEmail();

    MailerBuilder.withSMTPServer(&quot;smtp.gmail.com&quot;, 25, &quot;user&quot;, &quot;pass&quot;, SMTP_TLS)
            .buildMailer()
            .sendMail(email);

    MailerBuilder.withSMTPServer(&quot;smtp.gmail.com&quot;, 587, &quot;user&quot;, &quot;pass&quot;, SMTP_TLS)
            .buildMailer()
            .sendMail(email);

    MailerBuilder.withSMTPServer(&quot;smtp.gmail.com&quot;, 465, &quot;user&quot;, &quot;pass&quot;, SMTP_SSL)
            .buildMailer()
            .sendMail(email);

If you have two-factor login turned on, you need to generate an [application specific password](https://security.google.com/settings/security/apppasswords) from your Google account.
As a small note, it only started to work for me when I changed smtp to smtps in the examples above per samples from javamail (see smtpsend.java, https://github.com/javaee/javamail/releases/download/JAVAMAIL-1_6_2/javamail-samples.zip, option -S).

My resulting code is as follow:

    Properties props=new Properties();
    props.put(&quot;mail.smtps.starttls.enable&quot;,&quot;true&quot;);
    // Use the following if you need SSL
    props.put(&quot;mail.smtps.socketFactory.port&quot;, port);
    props.put(&quot;mail.smtps.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);
    props.put(&quot;mail.smtps.socketFactory.fallback&quot;, &quot;false&quot;);
    props.put(&quot;mail.smtps.host&quot;, serverList.get(randNum));
    Session session = Session.getDefaultInstance(props);

    smtpConnectionPool = new SmtpConnectionPool(
        SmtpConnectionFactories.newSmtpFactory(session));
        
    final ClosableSmtpConnection transport = smtpConnectionPool.borrowObject();
    ...
    transport.sendMessage(message, message.getAllRecipients());
I just spent quite a bit of time figuring out how to use JavaMail to send emails with gmail or office365. I couldn&#39;t find the answer in the [faq][1], but was helped a bit by the [javadoc][2].

If you forget `props.put(&quot;mail.smtp.starttls.enable&quot;,&quot;true&quot;)` you get `com.sun.mail.smtp.SMTPSendFailedException: 451 5.7.3 STARTTLS is required to send mail`.

If you forget `props.put(&quot;mail.smtp.ssl.protocols&quot;, &quot;TLSv1.2&quot;);` you get `javax.mail.MessagingException: Could not convert socket to TLS;` and `No appropriate protocol (protocol is disabled or cipher suites are inappropriate)`. Apparently this is only necessary for JavaMail versions 1.5.2 and older.

Here is the minimal code I required to get it to work:

    import java.util.Properties;
    import javax.mail.Authenticator;
    import javax.mail.Message;
    import javax.mail.MessagingException;
    import javax.mail.PasswordAuthentication;
    import javax.mail.Session;
    import javax.mail.Transport;
    import javax.mail.internet.InternetAddress;
    import javax.mail.internet.MimeMessage;
    
    public class SendEmail {
        public static void main(String[] args) {
            Properties props = new Properties();
            props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);
            props.put(&quot;mail.smtp.starttls.enable&quot;,&quot;true&quot;);
            // smtp.gmail.com supports TLSv1.2 and TLSv1.3
            // smtp.office365.com supports only TLSv1.2
            props.put(&quot;mail.smtp.ssl.protocols&quot;, &quot;TLSv1.2&quot;);
            props.put(&quot;mail.smtp.host&quot;, &quot;smtp.office365.com&quot;);
            props.put(&quot;mail.smtp.port&quot;, &quot;587&quot;);
            
            Session session = Session.getInstance(props, new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(&quot;test@example.com&quot;, &quot;******&quot;);
                }
            });
            
            try {
                Message message = new MimeMessage(session);
                message.setFrom(new InternetAddress(&quot;sender@example.com&quot;));
                message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(&quot;recipient@example.com&quot;));
                message.setSubject(&quot;You got mail&quot;);
                message.setText(&quot;This email was sent with JavaMail.&quot;);
                Transport.send(message);
                System.out.println(&quot;Email sent.&quot;);
            } catch (MessagingException e) {
                throw new RuntimeException(e);
            }
        }
    }


  [1]: https://javaee.github.io/javamail/FAQ
  [2]: https://javaee.github.io/javamail/docs/api/com/sun/mail/smtp/package-summary.html