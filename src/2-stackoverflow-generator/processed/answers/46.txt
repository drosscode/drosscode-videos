EDIT: [Marc&#39;s answer][1] is clearly the right way to go in this case, but I&#39;m leaving this answer here for posterity - it&#39;s a handy trick to know about in some cases, where you only need a partial class to change the inheritance/interfaces of a class.

I don&#39;t know of any automated way, but if you wanted to do this for multiple classes and *only* wanted to specify the base class, you might consider creating a file just for the partial class declarations. I use this approach in Protocol Buffers to make the internal representation classes which are autogenerated implement a particular interface.

See [PartialClasses.cs][2] for this example as code. (Ignore the TODO - it&#39;s fixed locally, but I haven&#39;t pushed for a little while :)


  [1]: https://stackoverflow.com/questions/411515/way-to-automatically-add-a-linqtosql-base-class-to-entities#411903
  [2]: http://github.com/jskeet/dotnet-protobufs/tree/master/src/ProtocolBuffers/DescriptorProtos/PartialClasses.cs
Some people have written their own code templates in place of the DBML approach. Going that route you can easily add the base classes yourself.

[LINQ to SQL template for Visual Studio 2008][1] is a good starting point


  [1]: http://damieng.com/blog/2008/09/14/linq-to-sql-template-for-visual-studio-2008
The LINQ-to-SQL code-generator supports this directly.

The base-class for the data-context can be set in the designer, as the `Base Class` property. Alternatively, edit the dbml directly: right click, &quot;Edit With...&quot;, &quot;XML Editor&quot;

To change the base class for the entities, set the type:

    &lt;Database EntityBase=&quot;Some.NameSpace.Foo&quot; ... &gt; 

To change the base class for the data-context, set the type:

    &lt;Database BaseType=&quot;Some.NameSpace.Bar&quot; ... &gt;

In both cases, use the fully-qualified type in the attribute. Et voila.

Note that because it is very literal, you can also use this approach to make your entities implement an interface - for example, when my classes have properties like `LastUpdated` and `UpdatedBy`, I might have an `IAuditable` interface that defines these. Then I can put code in my data-context&#39;s `SubmitChanges` (override) that calls `GetChangeSet()` and sets these values for all the `IAuditable` entities being updated; very sweet.