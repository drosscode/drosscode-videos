Before you decide that you need &#39;alternatives to winsock2&quot; please read this: &lt;a href=&quot;http://www.amazon.com/Network-Programming-Microsoft-Windows-Pro-Developer/dp/0735615799&quot;&gt;Network Programming for Microsoft Windows&lt;/a&gt;.

In summary, you DON&#39;T need an &#39;alternative to Winsock2&#39; you need to understand how to use the programming models supplied to full effect on the platform that you&#39;re targeting. Then, if you really ***need*** cross platform sockets code that uses async I/O then look at ASIO, but, if you don&#39;t *really need* cross platform code then consider something that actually focuses on the problems that you might have on the platform that you do need to focus on - i.e. something windows specific. Go back to the book mentioned above and take a look at the various options you have. 

The most performant and scalable option is to use IO Completion Ports. I have some free code available from [here][1] that makes it pretty easy to write a server that scales and performs well on a windows (NT) based platform; the linked page also links to some articles that I&#39;ve written about this. A comparison of my framework to ASIO can be found here:  http://www.lenholgate.com/blog/2008/09/how-does-the-socket-server-framework-compare-to-boostasio.html.


  [1]: http://www.serverframework.com/products---the-free-framework.html
  [2]: http://www.serverframework.com/products---the-free-framework.html
@Brian:

					if ((gConnections.size() + 1) &gt; 64) {
						// For the background on this check, see
						// www.tangentsoft.net/wskfaq/advanced.html#64sockets
						// The +1 is to account for the listener socket.
						cout &lt;&lt; &quot;WARNING: More than 63 client &quot;
								&quot;connections accepted.  This will not &quot;
								&quot;work reliably on some Winsock &quot;
								&quot;stacks!&quot; &lt;&lt; endl;
					}


To the OP:

Why would you not want to use winsock2? 
You could try to look at building your own server using IOCP, although making this cross-platform is a little tricky. You could look at Boost::asio like Brian suggested.
**Alternative library:** 

You should consider using [boost asio][1].  It is a cross platform networking library which simplifies many of the tasks you may have to do. 

You can find the [example source code you seek here][2]. 


----------

**About the 64 limit:**

There is no hard 64 connection limit that you will experience with a good design.  Basically if you use some kind of threading model you will not experience this limitation.

Here&#39;s some information on the limit you heard about:

&gt; 4.9 - What are the &quot;64 sockets&quot; limitations?
&gt; 
&gt; There are two 64-socket limitations:
&gt; 
&gt; The Win32 event mechanism (e.g.
&gt; WaitForMultipleObjects()) can only
&gt; wait on 64 event objects at a time.
&gt; Winsock 2 provides the
&gt; WSAEventSelect() function which lets
&gt; you use Win32&#39;s event mechanism to
&gt; wait for events on sockets. Because it
&gt; uses Win32&#39;s event mechanism, you can
&gt; only wait for events on 64 sockets at
&gt; a time. If you want to wait on more
&gt; than 64 Winsock event objects at a
&gt; time, you need to use multiple
&gt; threads, each waiting on no more than
&gt; 64 of the sockets.
&gt; 
&gt; The select() function is also limited
&gt; in certain situations to waiting on 64
&gt; sockets at a time. The FD_SETSIZE
&gt; constant defined in winsock.h
&gt; determines the size of the fd_set
&gt; structures you pass to select(). It&#39;s
&gt; defined by default to 64. You can
&gt; define this constant to a higher value
&gt; before you #include winsock.h, and
&gt; this will override the default value.
&gt; Unfortunately, at least one
&gt; non-Microsoft Winsock stack and some
&gt; Layered Service Providers assume the
&gt; default of 64; they will ignore
&gt; sockets beyond the 64th in larger
&gt; fd_sets.
&gt; 
&gt; You can write a test program to try
&gt; this on the systems you plan on
&gt; supporting, to see if they are not
&gt; limited. If they are, you can get
&gt; around this with threads, just as you
&gt; would with event objects.

[Source][3]


  [1]: http://www.boost.org/doc/libs/1_37_0/doc/html/boost_asio.html
  [2]: http://www.boost.org/doc/libs/1_37_0/doc/html/boost_asio/examples.html
  [3]: http://tangentsoft.net/wskfaq/advanced.html