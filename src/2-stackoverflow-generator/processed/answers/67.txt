If fixing the source of the error is not an option, you should look at this:
http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html

I believe using &quot;handle&quot; or &quot;try&quot; or &quot;catch&quot; or whatever from Control.Exception is the key here, the functions in the standard prelude only deal with IO-Exceptions, not with errors in pure code.

In Haskell98, pure code cannot deal with exceptions. Pure functions must return a value, an exception is a failure to return a value.

Example:

    import qualified Control.Exception as C
    x ::String
    x = undefined
    y = &quot;return value&quot;

    main = do C.handle (\_ -&gt; return &quot;caught&quot;) (C.evaluate x) &gt;&gt;= print
              C.handle (\_ -&gt; return &quot;caught&quot;) (C.evaluate y) &gt;&gt;= print

The call to evaluate is to force the evaluation of x and y, haskell being lazy and all.

If you let the evaluation of x be deferred until later (lazily), the exception will also be thrown later, in a different place (in this case it is &quot;print&quot; that uses the value), where it may not be caught.