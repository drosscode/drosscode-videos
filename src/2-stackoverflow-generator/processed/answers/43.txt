 1. From [MS Docs article on `IEquatable&lt;T&gt;`][1]:

    &gt; If you implement `IEquatable&lt;T&gt;`, you should also override the
    &gt; base class implementations of
    &gt; `Equals(Object)` and
    &gt; `GetHashCode()` so that their behavior is
    &gt; consistent with that of the
    &gt; `Equals(T)`
    &gt; method. If you do override
    &gt; `Equals(Object)`, your
    &gt; overridden implementation is also
    &gt; called in calls to the static
    &gt; `Equals(Object, Object)`
    &gt; method on your class. In addition,
    &gt; you should overload the `op_Equality`
    &gt; and `op_Inequality` operators.
    &gt; This ensures that all tests for equality
    &gt; return consistent results.

 2. No, [operators do not use the Equals method][Overloading Operator vs Equals]. They must be [overloaded separately][Overloadable Operators] to do so.


  [1]: https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1?view=netstandard-2.0
[Overloading Operator vs Equals]: https://stackoverflow.com/a/1849288/712526
[Overloadable Operators]: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/overloadable-operators
1) As Ray said, override `Equals(object)` to ensure consistency when the method is called from classes which don&#39;t know (statically) that you implement `IEquatable&lt;T&gt;`. For instance, the non-generic collections classes will use `Equals(object)` for comparisons. You should also override `GetHashCode()`.

2) Implementing `IEquatable&lt;T&gt;` doesn&#39;t overload the == and != operators automatically, but there&#39;s nothing to stop you from doing so, just like `System.String` does. You should document this very clearly if you do, however - and be careful when you make comparisons between other types of reference (e.g. MyType and Object) which will still use the identity comparison. I suspect it&#39;s not a great idea to do this unless it&#39;s going to be a very heavily used type in your code, where everyone will become very familiar with it *and* where the syntactic sugar of overloading == will really make a positive impact on readability.