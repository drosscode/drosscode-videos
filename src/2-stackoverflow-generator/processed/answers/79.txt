I&#39;m not sure about the proper terms here, but basically expression parameters are not equivalent even if they have the same name.

That means that

    var param1 = Expression.Parameter(typeof(T), &quot;item&quot;);
    var param2 = Expression.Parameter(typeof(T), &quot;item&quot;);

    param1 != param2

param1 and param2 won&#39;t be the same thing if used in an expression.

The best way to deal with this is create one parameter up front for your expression, and then pass it to all helper functions that need the parameter.

EDIT: Also, if you&#39;re trying to dynamically compose where clauses in LINQ, you could give [PredicateBuilder][1] a try.

[1]: http://www.albahari.com/nutshell/predicatebuilder.aspx
The issue is that the Expression you&#39;re creating in the method OrExpressions reuses the body of the two expressions. Those bodies will contain references to their own ParameterExpression that has been defined in FilterExpression.

A fix would be to rewrite the left and right parts to use the new ParameterExpression. Or to pass the original ParameterExpression along. It&#39;s not because the two ParameterExpression have the same name that they represent the same parameter.
As already suggested, [here][1] you can find this very nice (working) code
 
    public static Expression&lt;Func&lt;T, bool&gt;&gt; Or&lt;T&gt;(this Expression&lt;Func&lt;T, bool&gt;&gt; expr1, Expression&lt;Func&lt;T, bool&gt;&gt; expr2)
    {
        var invokedExpr = Expression.Invoke(expr2, expr1.Parameters.Cast&lt;Expression&gt;());
        return Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(Expression.Or(expr1.Body, invokedExpr), expr1.Parameters);
    }


that you can adapt to your needs and which isn&#39;t tied (IMHO) to LINQ.

  [1]: http://www.albahari.com/nutshell/predicatebuilder.aspx
For those, who found this page by a search engine and is going to use **the PredicateBuilder from Ben&amp;Joe Albahari**, watch out, since it **does not work with the Entity Framework**.

Try [this fixed version][1] instead.


  [1]: http://petemontgomery.wordpress.com/2011/02/10/a-universal-predicatebuilder/
Fabrizio&#39;s solution also occurred to me as well but since I was attempting to combine two expressions that would be executed as a linq 2 sql query, I thought it would execute in memory rather than the sql server.

I was wrote - Linq-To-Sql recognises that the invocation is of a lambda expression and thus still produces optimized sql.
