There are significant differences. Let&#39;s set up some test cases:

    var unused; // value will be undefined
    Test(&quot;test1&quot;, &quot;some value&quot;);
    Test(&quot;test2&quot;);
    Test(&quot;test3&quot;, unused);
    Test(&quot;test4&quot;, null);
    Test(&quot;test5&quot;, 0);
    Test(&quot;test6&quot;, &quot;&quot;);

With the first method you describe, only the second test will use the default value. The second method will default all but the first (as JS will convert `undefined`, `null`, `0`, and `&quot;&quot;` into the boolean `false`. And if you were to use Tom&#39;s method, only the fourth test will use the default!

Which method you choose really depends on your intended behavior. If values other than `undefined` are allowable for `argument2`, then you&#39;ll probably want some variation on the first; if a non-zero, non-null, non-empty value is desired, then the second method is ideal - indeed, it is often used to quickly eliminate such a wide range of values from consideration.
This is one of the few cases where I find the test:  

    if(! argument2) {  
    
    }

works quite nicely and carries the correct implication syntactically.

(With the simultaneous restriction that I wouldn&#39;t allow a legitimate null value for `argument2` which has some other meaning; but that would be **really** confusing.)

EDIT:

This is a really good example of a stylistic difference between loosely-typed and strongly-typed languages; and a stylistic option that javascript affords in spades.  

My personal preference (with no criticism meant for other preferences) is minimalism. The less the code has to say, as long as I&#39;m consistent and concise, the less someone else has to comprehend to correctly infer my meaning.  

One implication of that preference is that I don&#39;t want to - don&#39;t find it useful to - pile up a bunch of type-dependency tests. Instead, I try to make the code mean what it looks like it means; and test only for what I really will need to test for.  

One of the aggravations I find in some other peoples&#39; code is needing to figure out whether or not they expect, in the larger context, to actually run into the cases they are testing for. Or if they are trying to test for everything possible, on the chance that they don&#39;t anticipate the context completely enough. Which means I end up needing to track them down exhaustively in both directions before I can confidently refactor or modify anything. I figure that there&#39;s a good chance they might have put those various tests in place because they foresaw circumstances where they would be needed (and which usually aren&#39;t apparent to me).

(I consider that a serious downside in the way these folks use dynamic languages. Too often people don&#39;t want to give up all the static tests, and end up faking it.)

I&#39;ve seen this most glaringly in comparing comprehensive ActionScript 3 code with elegant javascript code. The AS3 can be 3 or 4 times the bulk of the js, and the reliability I suspect is at least no better, just because of the number (3-4X) of coding decisions that were made.

As you say, Shog9, YMMV. :D
I&#39;m sorry, I still yet cant comment, so to answer Tom&#39;s answer...
In javascript (undefined != null) == false
In fact that function wont work with &quot;null&quot;, you should use &quot;undefined&quot;
There are several different ways to check if an argument was passed to a function. In addition to the two you mentioned in your (original) question - checking `arguments.length` or using the `||` operator to provide default values - one can also explicitly check the arguments for `undefined` via `argument2 === undefined` or `typeof argument2 === &#39;undefined&#39;` if one is paranoid (see comments).

Using the `||` operator has become standard practice - all the cool kids do it - but be careful: The default value will be triggered if the argument evaluates to `false`, which means it might actually be `undefined`, `null`, `false`, `0`, `&#39;&#39;` (or anything else for which `Boolean(...)` returns `false`).

So the question is when to use which check, as they all yield slightly different results.

Checking `arguments.length` exhibits the &#39;most correct&#39; behaviour, but it might not be feasible if there&#39;s more than one optional argument.

The test for `undefined` is next &#39;best&#39; - it only &#39;fails&#39; if the function is explicitly called with an `undefined` value, which in all likelyhood should be treated the same way as omitting the argument.

The use of the `||` operator might trigger usage of the default value even if a valid argument is provided. On the other hand, its behaviour might actually be desired.

To summarize: *Only use it if you know what you&#39;re doing!*

In my opinion, using `||` is also the way to go if there&#39;s more than one optional argument and one doesn&#39;t want to pass an object literal as a workaround for named parameters.

Another nice way to provide default values using `arguments.length` is possible by falling through the labels of a switch statement:

    function test(requiredArg, optionalArg1, optionalArg2, optionalArg3) {
        switch(arguments.length) {
            case 1: optionalArg1 = &#39;default1&#39;;
            case 2: optionalArg2 = &#39;default2&#39;;
            case 3: optionalArg3 = &#39;default3&#39;;
            case 4: break;
            default: throw new Error(&#39;illegal argument count&#39;)
        }
        // do stuff
    }


This has the downside that the programmer&#39;s intention is not (visually) obvious and uses &#39;magic numbers&#39;; it is therefore possibly error prone.
There is a [tricky way as well to find, whether a parameter is passed to a function or not](https://codeschool.com/discuss/t/shaping-up-with-angularjs-level-2-challenge-9/4958/3). Have a look at the below example:


    this.setCurrent = function(value) {
      this.current = value || 0;
    };

This necessary means that if the value of `value` is not present/passed - set it to 0.

Pretty cool huh!
In ES6 (ES2015) you can use [Default parameters][1]

&lt;!-- begin snippet: js hide: false console: true babel: true --&gt;

&lt;!-- language: lang-js --&gt;

    function Test(arg1 = &#39;Hello&#39;, arg2 = &#39;World!&#39;){
      alert(arg1 + &#39; &#39; +arg2);
    }

    Test(&#39;Hello&#39;, &#39;World!&#39;); // Hello World!
    Test(&#39;Hello&#39;); // Hello World!
    Test(); // Hello World!

&lt;!-- end snippet --&gt;

  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters
It can be convenient to approach argument detection by evoking your function with an Object of optional properties:


    function foo(options) {
        var config = { // defaults
	        list: &#39;string value&#39;,
	        of: [a, b, c],
	        optional: {x: y},
	        objects: function(param){
	           // do stuff here
	        }
	    }; 
	    if(options !== undefined){
	    	for (i in config) {
				if (config.hasOwnProperty(i)){
					if (options[i] !== undefined) { config[i] = options[i]; }
				}
			}
        }
    }
If you are using jQuery, one option that is nice (especially for complicated situations) is to use [jQuery&#39;s extend method][1].

    function foo(options) {

        default_options = {
            timeout : 1000,
            callback : function(){},
            some_number : 50,
            some_text : &quot;hello world&quot;
        };

        options = $.extend({}, default_options, options);
    }

If you call the function then like this:

    foo({timeout : 500});

The options variable would then be:

    {
        timeout : 500,
        callback : function(){},
        some_number : 50,
        some_text : &quot;hello world&quot;
    };


  [1]: http://api.jquery.com/jQuery.extend/
Why not using the `!!` operator? This operator, placed before the variable, turn it to a boolean (if I&#39;ve understood well), so `!!undefined` and `!!null` (and even `!!NaN`, which can be quite interesting) will return `false`.

Here is an exemple:

    function foo(bar){
        console.log(!!bar);
    }

    foo(&quot;hey&quot;) //=&gt; will log true

    foo() //=&gt; will log false

Some times you may also want to check for type, specially if you are using the function as getter and setter. The following code is ES6 (will not run in EcmaScript 5 or older):

    class PrivateTest {
        constructor(aNumber) {
            let _aNumber = aNumber;

            //Privileged setter/getter with access to private _number:
            this.aNumber = function(value) {
                if (value !== undefined &amp;&amp; (typeof value === typeof _aNumber)) {
                    _aNumber = value;
                }
                else {
                    return _aNumber;
                }
            }
        }
    }

    url = url === undefined ? location.href : url;
fnCalledFunction(Param1,Param2, window.YourOptionalParameter)


If above function is called from many places and you are sure first 2 parameters are passed from every where but not sure about 3rd parameter then you can use window.  

window.param3 will handle if it is not defined from the caller method.
```js
function example(arg) {
  var argumentID = &#39;0&#39;; //1,2,3,4...whatever
  if (argumentID in arguments === false) {
    console.log(`the argument with id ${argumentID} was not passed to the function`);
  }
}
```
Because arrays inherit from `Object.prototype`. Consider â‡‘ to make the world better.
Sometimes you want undefined as a possible argument but you still have situations where the argument may not be passed. In that case you can use `arguments.length` to check how many arguments were passed.

```

// Throw error if the field is not matching our expectations
function testField(label, fieldValue, expectedValue) {
    console.log(arguments) // Gives: [Arguments] { &#39;0&#39;: &#39;id&#39;, &#39;1&#39;: 1, &#39;2&#39;: undefined }
    if(arguments.length === 2) {
        if(!fieldValue) {
            throw new Error(`Field &quot;${label}&quot; must have a value`)
        }
    }

    else if(expectedValue === undefined) {
        if(fieldValue !== undefined) {
            throw Error(`Field &quot;${label}&quot; must NOT have a value`)
        }
    }

    // We stringify so our check works for objects as well
    else {
        if(JSON.stringify(fieldValue) !== JSON.stringify(expectedValue)) {
            throw Error(`Field &quot;${label}&quot; must equal ${expectedValue} but was ${fieldValue}`)
        }
    }
}
```

`testField(&#39;id&#39;, 12)` -&gt; Passes, we don&#39;t want id to be blank

`testField(&#39;id&#39;, undefined, undefined)` -&gt; Passes, we want id to be undefined

`testField(&#39;id&#39;, 12, undefined)` -&gt; Errors, we wanted id to be undefined
 
